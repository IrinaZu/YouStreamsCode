package codesjava;

import java.io.File;
import java.io.FileWriter;
import java.lang.reflect.Method;

/**
 * Утилитный класс для рефлексии. Поле хранит номера ранее созданных адаптеров,
 * метод порождает потмоков от требуемого класса и делает их реализующими 
 * требуемый интерфейс.
 * 
 * @author Ermakov Alexander
 */
public class Reflector {

    private static int x;

    /**
     * Метод адаптации класса под интерфейс. Метод создает класс,
     * который будет потомком заданного класса и при этом будет реализовывать
     * необходимый интерфейс. Это, конечно не совсем корректный адаптер,
     * но будем звать его так. Для этого сначала генерируется .java файл с
     * требуемым кодом, затем запускатеся процесс его компиляции и далее
     * возвращается имя .class файла.
     * 
     * В самом методе куча условностей, в частности:
     * 1. От исходного класса обязательно можно унаследоваться. final классы сразу
     * отпадают.
     * 2.Требуемый интерфейс имеет строго один метод требующий реализации.
     * 3.Метод с требуемым названием и без параметров уже есть в исходном классе.
     * 4.При каждом обращении делается новый класс, даже если нужный класс уже
     * генерировался раньше.
     * 5.Корректно работает только если метод void
     * 6.Крайне туманно происходит определение того, где искать все требуемые
     * классы и интерфейсы при компиляции. В моем проекте предполагалось,
     * что текущая рабочая папка виртульаной машины настроена на корневую
     * папку .class файлов и тогда все работает.
     * 7.Если компиляция окажется неудачной - никто ни о чем не узнает и имя
     * все равно будет возвращено. Возможно стоит возвращать Class.
     * 
     * @param obj
     *      Класс который имеет метод moo, но не реализует требуемый интерфейс
     * @param target
     *      Интерфейс, который требуется реализовать
     * @return 
     *      Имя класса, который был сгенерирован данным методом
     * @throws java.lang.Exception
     *      Как обычно, куча необработанных рефлексивных исключений
     * @author Ermakov Alexander
     */        
    public static String adapt(Class obj, Class target) throws Exception {
        String className = obj.getSimpleName() + "Adapted" + x;
        FileWriter out
                = new FileWriter(className + ".java");
        Method m = target.getDeclaredMethods()[0];
        out.append(
                "class " + className + " extends " + obj.getName() + " implements " + target.getName() + "{ \n"
                + " public " + m.getReturnType().getName() + " " + m.getName() + " ( ) { \n"
                + "super." + m.getName() + "();\n"
                + " } \n"
                + "} "
        );
        out.close();
        File f = new File("");
        Process p
                = Runtime.getRuntime().exec("javac -cp " + f.getAbsolutePath() + " " + f.getAbsolutePath() + "\\" + className + ".java");
        p.waitFor();
        return className;
    }
}
